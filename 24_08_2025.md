## Intuition

The problem asks for the length of the longest subarray of **1s** that can be achieved after **deleting exactly one element** from the original array. This means we are looking for the longest continuous sequence of 1s (potentially separated by the *one* element we choose to delete).

Since we are looking for the longest *continuous* segment, the **Sliding Window** technique is suitable. The key constraint is that the resulting subarray must contain only 1s, implying that the window we are tracking in the original array can contain **at most one 0**. The element we delete will be the 0 (if present) or one of the 1s (if the window is all 1s).

**Hint:** Keep the window valid by ensuring it has at most one zero. If a second zero is encountered, we shrink the window from the left until the first zero is removed, and the window becomes valid again. The length of the resulting 1s array will always be the current window size $\\mathbf{(j - i + 1)}$ minus the one element that must be deleted, which is $\\mathbf{j - i}$.

## Approach

We use a **Sliding Window** defined by two pointers, $i$ (start) and $j$ (end).

1.  **Initialization:**

      * Initialize $i=0$ and $j=0$.
      * `maxlen = -1` (to track the maximum length of the 1s subarray found so far).
      * `counter = -1` (to track the index of the single zero allowed in the window $[i, j]$).

2.  **Expansion (`j++`):** Iterate $j$ from $0$ to $n-1$, expanding the window.

3.  **Handling Zeros (`nums[j] === 0`):**

      * **Case 1: Second Zero Encountered (`counter !== -1`)**
          * The window is currently invalid (two zeros: one at `counter` and the new one at $j$).
          * We record the length of the **previous valid window** (which contained the zero at `counter`): `Math.max(maxlen, j - i - 1)`. The length here is $j-i$ (current window length) minus the two zeros, which is slightly convoluted but essentially records the valid length before $j$.
          * **Shrink the window:** Move the start pointer $i$ to the position immediately after the *first* zero: $\\mathbf{i = counter + 1}$.
          * Update `counter` to track the *new* zero: $\\mathbf{counter = j}$.
      * **Case 2: First Zero Encountered (`counter === -1`)**
          * The window is valid. Record the index of the first zero: $\\mathbf{counter = j}$.

4.  **Updating Max Length (in all cases):**

      * The length of the 1s subarray obtainable from the current valid window $[i, j]$ (by removing one element) is calculated as: **`j - i`**.
      * $\\mathbf{maxlen = \\text{Math.max}(\\text{maxlen}, j - i)}$.

5.  **Return:** After the loop finishes, `maxlen` holds the maximum length.

-----

## Complexity

  - Time complexity: **$O(n)$**

      * The two pointers, $i$ and $j$, traverse the array linearly, and each element is processed a constant number of times. The operations inside the loop are $O(1)$.

  - Space complexity: **$O(1)$**

      * The algorithm only uses a few constant-space variables (`i`, `j`, `counter`, `maxlen`, `n`) regardless of the input size $n$.

-----

## Code

```javascript []
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestSubarray = function(nums) {
    let counter=-1,n=nums.length;
    let maxlen=-1;
    let i=0,j=0;
    while(j<n){
        if(nums[j]===0){
            // If a second zero is encountered
            if(counter!==-1){
                // The current window length *before* j is j-i. Removing the zero at counter leaves j-i-1 length of 1s.
                // This line is optional as the final update 'j-i' handles it, but it doesn't hurt the correctness.
                maxlen=Math.max(maxlen,j-i-1);
                
                // Shrink the window: start i right after the first zero (at counter)
                i=counter+1;
                // Update counter to the new zero's index
                counter=j;
            }
            // If this is the first zero in the window
            else{
                counter=j;
            }
        }
        
        // Calculate the current maximum length: (Window Size) - 1, which is (j - i + 1) - 1 = j - i
        maxlen=Math.max(maxlen,j-i);
        
        // Expand the window
        j++;
    }
    
    // The final maxlen is correct. It handles the case of all 1s (where maxlen will be n-1)
    // and the case where zeros are present.
    return maxlen;
};
```
